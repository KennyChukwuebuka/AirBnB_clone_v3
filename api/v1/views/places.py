#!/usr/bin/python3
"""
Create a new view for Place objects
that handles all default RESTFul API actions:

In the file api/v1/views/places.py
You must use to_dict() to retrieve an object into a valid JSON
Update api/v1/views/__init__.py to import this new file
Retrieves the list of all Place objects of a
City: GET /api/v1/cities/<city_id>/places

If the city_id is not linked to any City object, raise a 404 error
Retrieves a Place object. : GET /api/v1/places/<place_id>

If the place_id is not linked to any Place object, raise a 404 error
Deletes a Place object: DELETE /api/v1/places/<place_id>

If the place_id is not linked to any Place object, raise a 404 error
Returns an empty dictionary with the status code 200
Creates a Place: POST /api/v1/cities/<city_id>/places

You must use request.get_json from Flask to transform
the HTTP request to a dictionary
If the city_id is not linked to any City object, raise a 404 error
If the HTTP request body is not valid JSON, raise
a 400 error with the message Not a JSON
If the dictionary doesn’t contain the key user_id,
raise a 400 error with the message Missing user_id
If the user_id is not linked to any User object, raise a 404 error
If the dictionary doesn’t contain the key name,
raise a 400 error with the message Missing name
Returns the new Place with the status code 201
Updates a Place object: PUT /api/v1/places/<place_id>

If the place_id is not linked to any Place object, raise a 404 error
You must use request.get_json from Flask to
transform the HTTP request to a dictionary
If the HTTP request body is not valid JSON,
raise a 400 error with the message Not a JSON
Update the Place object with all key-value
pairs of the dictionary
Ignore keys: id, user_id, city_id, created_at and updated_at
Returns the Place object with the status code 200

For the moment, the only way to list Place
objects is via GET /api/v1/cities/<city_id>/places.

Good, but not enough…

Update api/v1/views/places.py to add a new
endpoint: POST /api/v1/places_search that
retrieves all Place objects depending of
the JSON in the body of the request.

The JSON can contain 3 optional keys:

states: list of State ids
cities: list of City ids
amenities: list of Amenity ids
Search rules:

If the HTTP request body is not valid JSON,
raise a 400 error with the message Not a JSON
If the JSON body is empty or each list of all
keys are empty: retrieve all Place objects
If states list is not empty, results should
include all Place objects for each State id listed
If cities list is not empty, results should
include all Place objects for each City id listed
Keys states and cities are inclusive. Search
results should include all Place objects in
storage related to each City in every State
listed in states, plus every City listed
individually in cities, unless that City
was already included by states.
Context:
State A has 2 cities A1 and A2
State B has 3 cities B1, B2 and B3
A1 has 1 place
A2 has 2 places
B1 has 3 places
B2 has 4 places
B3 has 5 places
Search: states = State A and cities = B2
Result: all 4 places from the city B2 and
the place from the city A1 and the 2 places
of the city A2 (because they are part of State A) =>
7 places returned
If amenities list is not empty, limit search
results to only Place objects having all Amenity ids listed
The key amenities is exclusive, acting as a
filter on the results generated by states and
cities, or on all Place if states and cities
are both empty or missing.
Results will only include Place objects
having all listed amenities. If a Place
oesn’t have even one of these amenities, it won’t be retrieved.
"""

from api.v1.views import app_views
from flask import jsonify, abort, request
from models import storage
from models.place import Place
from datetime import datetime
import uuid


@app_views.route('/cities/<city_id>/places', methods=['GET'])
def list_places(city_id):
    '''Retrieves the list of all Place objects'''
    all_places = storage.all("Place").values()
    list_places = [obj.to_dict() for obj in all_places
                   if obj.city_id == city_id]
    return jsonify(list_places)


@app_views.route('/places/<place_id>', methods=['GET'])
def get_place(place_id):
    '''Retrieves a Place object'''
    all_places = storage.all("Place").values()
    place_obj = [obj.to_dict() for obj in all_places
                 if obj.id == place_id]
    if place_obj:
        return jsonify(place_obj[0])
    abort(404)


@app_views.route('/places/<place_id>', methods=['DELETE'])
def delete_place(place_id):
    '''Deletes a Place object'''
    place_obj = storage.get("Place", place_id)
    if place_obj:
        storage.delete(place_obj)
        storage.save()
        return jsonify({}), 200
    abort(404)


@app_views.route('/cities/<city_id>/places', methods=['POST'])
def create_place(city_id):
    '''Creates a Place'''
    if not request.get_json():
        abort(400, description="Not a JSON")
    if 'user_id' not in request.get_json():
        abort(400, description="Missing user_id")
    if not storage.get("User", request.get_json()['user_id']):
        abort(404)
    if 'name' not in request.get_json():
        abort(400, description="Missing name")
    new_place = Place(**request.get_json())
    new_place.city_id = city_id
    new_place.save()
    return jsonify(new_place.to_dict()), 201


@app_views.route('/places/<place_id>', methods=['PUT'])
def updates_place(place_id):
    '''Updates a Place object'''
    place_obj = storage.get("Place", place_id)
    if not place_obj:
        abort(404)
    if not request.get_json():
        abort(400, description="Not a JSON")
    for key, value in request.get_json().items():
        if key not in ['id', 'user_id', 'city_id', 'created_at', 'updated_at']:
            setattr(place_obj, key, value)
    place_obj.save()
    return jsonify(place_obj.to_dict())
